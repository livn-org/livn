begintemplate ISCell


public connect2target, subsets, is_art, is_connected
public all, soma, basal, apical, ais, hillock, axon, allaxon
public somaidx, basalidx, apicalidx, axonidx, aisidx, hilidx
public xx, yy, zz, position

objref rootlist
objref dendidx, apicalidx, basalidx, somaidx, axonidx, aisidx, hilidx
objref pyenv

objref all, basal_list, apical_list, dendrite_list, soma_list, axon_list, ais_list, hillock_list

create sections[1]

gid = -1

ndends   = -1
ndendsec = -1
nDends   = -1

// strings
strdef myroot

proc assert() { local test strdef errmsg
    
    test = $1
    errmsg = $s2
    
    if (!test) {
        execerror ("Assertion failed: ", errmsg)
    }
}

iterator pyitr() {local i, k, x, n, sz localobj itr1, itrn
    sz = $1
    n = (numarg()-1) / 2
    i = 1+n+1
    itr1 = $oi
    
    for k = 0, sz-1 {
        for x = 1, n {
            i = 1+n+x
            itrn = $oi
            i = 1+x
            $&i = itrn.__next__()
        }
        iterator_statement
    }
}


proc init() {
	gid = $1
        
        apicalidx = new Vector()
        basalidx = new Vector()
        somaidx = new Vector()
        dendidx = new Vector()
        axonidx = new Vector()
        aisidx = new Vector()
        hilidx = new Vector()
        
        pyenv = new PythonObject()
    	nrnpython("import numpy as np")
        
        shape_from_python($o2,$o7,$o8,$o9,$o10)
        topol_from_python($o2,$o3,$o4,$o5,$o6,$o11)
        
	define_shape()		// builtin fcn: fill in 3d info for sections defined by only L and diam, translate 3d points for consistency with their connections 
            
  	append_sections()	// local fcn: append all sections to the section list
	set_nseg()			// local fcn: set the number of segments in each section
	get_root()			// local fcn: perform morphology checks

	// electrophysiology
	biophys()			// local fcn: set values for max conductances and reversal potentials of ion channels and other ephys parameters that are subject to fitting
}

objref all, basal_list, apical_list, dendrite_list, soma_list, axon_list, ais_list, hillock_list
proc append_sections() { local i
	objref all, basal_list, apical_list, dendrite_list, soma_list, axon_list

	all = new SectionList()
	basal_list = new SectionList()
	apical_list = new SectionList()
	soma_list = new SectionList()
	axon_list = new SectionList()
	ais_list = new SectionList()
	hillock_list = new SectionList()
	dendrite_list = new SectionList()

	sections[somaidx.x[0]] all.append()
	sections[somaidx.x[0]] soma_list.append()
        for i=0, dendidx.size()-1 {
		sections[dendidx.x[i]] all.append()
		sections[dendidx.x[i]] dendrite_list.append()
	}

	for i=0, apicalidx.size()-1 {
		sections[apicalidx.x[i]] apical_list.append()
	}

	for i=0, basalidx.size()-1 {
		sections[basalidx.x[i]] basal_list.append()
	}

	for i=0, axonidx.size()-1 {
		sections[axonidx.x[i]] all.append()
		sections[axonidx.x[i]] axon_list.append()
	}
}


external lambda_f
proc set_nseg() {
  	forsec all { nseg = int((L/(0.1*lambda_f(100))+.9)/2)*2 + 1  }
    }
    

proc get_root() {local i localobj sref
	rootlist = new SectionList()
	rootlist.allroots()
	i=0
	forsec all {
		sref = new SectionRef()
		if (sref.has_parent==0) {
			myroot = secname()
			i=i+1
		}
		for(x,0) {
			if (diam(x) <=0.01) print "WARNING: tiny diameter of ",  diam(x), " um at ", secname(), ", point ", x, "!"
			if (diam3d(x) <=0.01) print "WARNING: tiny 3d diameter of ", diam3d(x), " um at ", secname(), ", point ", x, "!"
		}
		if (L <=0.001) print "WARNING: tiny length of ", L, " um at ", secname(), "!"
	}
	if (i>1) {
		print "WARNING: cell ", gid, " has ", i, " root sections!"
	}
}
    

proc biophys() {
    
    forsec all {
        Ra=100
    }


    sections[somaidx.x[0]] {
	    distance()
    }

    forsec all {
	insert ccanl
	catau_ccanl = 1
	caiinf_ccanl = 5.e-6
	insert borgka
	gkabar_borgka=0.0008
	insert nca  // HAV-N- Ca channel
	gncabar_nca=0.0  
	insert lca
	glcabar_lca=0.0015
	insert gskch
	gskbar_gskch=0.003
	insert cagk
	gkbar_cagk=0.003
	insert hyperde3
	ghyfbar_hyperde3=0.000015
	ghysbar_hyperde3=0.000015
    }
    
    forsec soma_list {
        insert ichan2  //ildikos ichan
	gnatbar_ichan2=0.2  
	gkfbar_ichan2=0.006  
	gl_ichan2 = 0.000036
        cm=0.5
    } 
    
    forsec apical_list {
        for (x,0) {
            insert ichan2
            cm=1.1
            if (distance(x) <= 150) {
	        gnatbar_ichan2=0.2  
	        gkfbar_ichan2=0.006
	        gl_ichan2 = 0.000036
            } else {
	        gnatbar_ichan2=0.0
	        gkfbar_ichan2=0.00
	        gl_ichan2 = 0.000036
            }
        }
    }
    
    forsec basal_list {
        for (x,0) {
            insert ichan2
            cm=1.1
            if (distance(x) <= 150) {
	        gnatbar_ichan2=0.2  
	        gkfbar_ichan2=0.006
	        gl_ichan2 = 0.000036
            } else {
	        gnatbar_ichan2=0.0
	        gkfbar_ichan2=0.00
	        gl_ichan2 = 0.000036
            }
        }
    }
    
    
    forsec all {
        enat = 55
        ekf = -90
        ek= -90
        esk= -90
        elca=130
	el_ichan2 =-70.45
	ehyf=-40 ehys=-40
        cao_ccanl=2
    }  // make catau slower70e-3 	cao=2 cai=50.e-6 
    
}



proc topol_from_python() { local i,j,l,p,s,p_layer,loc,vlen localobj vsrc, vdst, vloc, secnodes, layers, swc_types
    
    secnodes = $o1
    layers   = $o2
    
    vlen     = $o3.size
    vsrc     = pyenv.iter($o3)
    vdst     = pyenv.iter($o4)
    vloc     = pyenv.iter($o5)
    swc_types = $o6
    
    nDends = 0
    nSoma  = 0
    nAxon  = 0
    nAIS   = 0
    nHill  = 0
    
    for s=0, secnodes.__len__()-1 {
        
        p = secnodes.__getitem__(s)._[-1]
        p_layer = layers._[p]
        swc_type = swc_types._[p]

        if (swc_type == 4) {
            nDends = nDends + 1
            dendidx.append(s)
            apicalidx.append(s)
        }
        if (swc_type == 3) {
            nDends = nDends + 1
            dendidx.append(s)
            basalidx.append(s)
        }
        if (swc_type == 8) {
            hilidx.append(s)
            nHill = nHill + 1
            nAxon = nAxon + 1
        }
        if (swc_type == 7) {
            aisidx.append(s)
            nAIS = nAIS + 1
            nAxon = nAxon + 1
        }
        if (swc_type == 2) {
            axonidx.append(s)
            nAxon = nAxon + 1
        }
        if (swc_type == 1) {
            somaidx.append(s)
            nSoma = nSoma + 1
        }
        
    }
    
    for pyitr (vlen, &i, &j, &l, vsrc, vdst, vloc) {
        assert (i >= 0,  "compartment index in topology matrix is less than zero")
        assert (j >= 0,  "compartment index in topology matrix is less than zero")
        assert (i < nDends+nSoma+nAxon+1,  "compartment index in topology matrix is greater than the number of compartments")
        assert (j < nDends+nSoma+nAxon+1,  "compartment index in topology matrix is greater than the number of compartments")
        sections[i] loc = arc3d(l) / L 
        connect sections[j](0),sections[i](loc)
        
    }
    
}


proc shape_from_python() { local x,y,z,r,s,p localobj secnodes, pidxs, vx, vy, vz, vradius
    
    secnodes = $o1
    vx = $o2
    vy = $o3
    vz = $o4
    vradius = $o5
    
    create sections[secnodes.__len__()]
    for s=0, secnodes.__len__()-1 {
        pidxs = secnodes.__getitem__(s)
        sections[s] {
            pt3dconst(0)
            for pyitr (pidxs.size, &p, pyenv.iter(pidxs)) {
                
                x = vx._[p]
                y = vy._[p]
                z = vz._[p]
                r = vradius._[p]

                pt3dadd(x, y, z, 2*r)
            }
        }
    }
    
}


func is_art()  { return 0 }

obfunc connect2target() { localobj nc // $o1 target point process, optional $o2 returned NetCon
    forsec soma_list {
        nc = new NetCon(&v(1), $o1)
    }
    nc.threshold = -20
    if (numarg() == 2) { $o2 = nc } // for backward compatibility
    return nc
}

proc position() { local i
    
  soma for i = 0, n3d()-1 {
    pt3dchange(i, $1-xx+x3d(i), $2-yy+y3d(i), $3-zz+z3d(i), diam3d(i))
  }
  xx = $1  yy = $2  zz = $3
}

endtemplate ISCell
